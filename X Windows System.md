## X Windows System

### 概要

![X logo](http://markdownnotebucket-1251801748.cossh.myqcloud.com/linux%2520learning/X-logo.png)

X Windows System（X11，，或者简称为 X）是一种用于显示位图的视窗系统，常见于UNIX-like的电脑操作系统中。X提供了基本的GUI运行环境框架，例如窗口在显示器上的绘制和移动，以及和外设的交互等。



### 目的和能力

X是一种架构无关的系统，可用于远程的用户图形和输入设备交互。值得注意的是，X并不要求一个用户界面，而是每个单独的用户程序在管理这些。独立的程序会可以在没有用户界面的情况下调度X的图形能力，所以，不同程序的可视化样式会非常不同，这就带来了不同的程序可能呈现出非常不同的界面。

不像很多早期的显示协议，X专门就是为了网络连接的显示而非本地集成的显示设备而创造的。X有网络透明性的特点（Network transparency），也就意味着X程序可以在某处的电脑上运行，而其图像可以在另一个有**X server运行的联网电脑上运行**，若该电脑还提供了显示设备和输入输出外设的话，就可以实现一个远程化的交互。

需要注意的是，在这样一套协议里，用户接触的其实是X的server端而远程跑程序的确是客户端。因为用户的图形显示界面和输入输出设备的图像和交互正是由本地的X server才能为本地和远程的X客户程序所使用。

X的网络协议是继续X的命令原语的，它支持2D和3D（通过例如像[GLX](https://www.wikiwand.com/en/GLX)（Open**GL** Extension to the **X** Window System），它提供了OpenGL和X之间的一个交互接口），并借此能让X客户程序来加速X server的显示。例如，再典型的OpenGL（3.0版本之前），显示列表（[Display List](https://www.wikiwand.com/en/Display_list)）中包含有大量的的可被用于由远程X 客户端程序在X server中建立和储存的对象，每个对象都是由单个[glCallList](https://msdn.microsoft.com/en-us/library/windows/desktop/dd318369(v=vs.85).aspx)信号来在网络间传送的。

*简单来说，Display list（或者 Display file）是一串包含了定义输出图像的OpenGL图形指令，一个图像生成（或传送）是通过执行这样一串指令和一些原语的*

*更多详见：http://www.glprogramming.com/red/chapter07.html*

X 并不原生支持声音信息的传送，不过有一些第三方的项目弥补了这个空缺。

*改扩展插件声称支持audio的传输，尚未验证 http://www.chaoticmind.net/~hcb/murx/xaudio/*



### 软件协议和架构

X 是一个用于位图显示的网络透明性的视窗系统（network-transparent windowing system for bitmap display）

#### Client-server模型和网络透明性

![X11模型示意图](http://markdownnotebucket-1251801748.cossh.myqcloud.com/linux%2520learning/X11-structure.png)

X使用了client-server模型，一个X server的程序跑在一个有显示设备和可以和许多客户程序通信的电脑上。X server作为一个用户和客户程序之间交互的中间者（go-between），它在TCP 6000端口上监听许可需要图形输出的请求，并接受用户的输入（鼠标、键盘）传回到客户端程序。

X中，server跑在用户的电脑上，而客户端有可能是泡在远端的机子上的，这个定义上与传统的C-S模型架构是相反的，传统定义中客户端常运行在用户电脑上而服务端运行在远程电脑上。X Window程序是一切的核心，它接收和响应来自应用程序的请求以及用户的键鼠输入，这样一来，可以视程序（远端机器）为使用X Window server程序的客户端。

X在端与端之间的通信协议实现网络透明性：客户端和服务器可以跑在同一个或者不同的机器上，也可能有着不同的架构和操作系统。一个客户程序和服务器可以通过在一个加密的链接下将链接隧道化（tunneling）达到安全的互联网通信。

### 设计原则

Bob Scheifler 和 Jim Gettys 陈述的早期 X 的基本原则如下（Scheifler/Gettys 于 1996 所列）：

·       不要加入新的功能，除非没有它就不能完成实际所需的应用程序。

·       决定一个系统不是什么和决定系统是什么同样重要。不要满足全部的需求；而是使系统具有可扩充性，额外的需求可以向上兼容的方式来满足。

·       只有完全没实例，才会比只有一个实例来的更糟。

·       如果没把问题弄清楚，不解决它也许会是最好的。

·       如果预期要用 90% 的努力去完成 10% 的工作，就用更简单的方法解决。（参见[更糟就是更好](https://www.wikiwand.com/zh/%E6%9B%B4%E7%B3%9F%E5%B0%B1%E6%98%AF%E6%9B%B4%E5%A5%BD)。）

·       尽量避免复杂性。

·       提供机制而不是提供方针，用户接口的方针由实际应用者自主。

后来在设计 X11 时，将第一项原则修改为：「不要加入新的功能，除非你知道某些实际的应用程序会需要它」。X 基本上一直遵循这些原则，参考实现的扩充及改进也是以此原则来着手，也因为奉行上述原则，使至今的最新版 X 仍能与最初（1987年）发布的协议标准几乎完全兼容。

 

### 核心协议

#### 概览

X Window核心协议是X Window系统的基础协议，它是一个位图（Bitmap）显示的网络化视窗系统，用于在Unix、类Unix和其他操作系统上建立用户界面。

![C-S通信图示](http://markdownnotebucket-1251801748.cossh.myqcloud.com/linux%2520learning/C-S%20communication.png)

服务器和客户端的交流是通过在互联网通道内交换包的形式进行的。客户端建立连接，并发送第一个包，服务器会通过发回一个表明接受或拒绝信息的包来进行应答，或者是发回一个请求更多验证信息的请求。如果链接被许可，许可的包会包含供客户端后续与服务器交互使用的数据。

在连接建立后 ，客户端和服务器会在通道内进行四种形式的包交换：

1. Request: 客户端会向服务器请求信息或请求服务器进行一个操作
2. Reply: 服务器会针对Request回复一个请求，但不是所有Request都会产生一个Reply
3. Event: 服务器会发送一个事件给客户端，例如：键鼠的输入，或者一个视窗被移动、调整大小、打开
4. Error: 服务器在Request无效的时候返回一个错误的包，由于所有的Requests会进行一个队列操作，并不是所有Error包都能及时发出。

X server提供了一系列基础的服务，而客户端也通过与服务器的交互实现更多复杂的功能。



*临时整理的Keynotes*

窗口里的内容并非在所有时候都能显示出来。更精确地说，在窗口移动、重设大小、被其他窗口遮盖、部分或整个窗口不可见时，窗口里的内容就有可能会被销毁。更精确地说，如果 X 服务器无法维护窗口内容的**后备存放区**（backing store）时，这些内容就会遗失。客户端可请求为窗口进行维护的后备存放区，但服务器没有义务要这样做。因此，客户端不可假设已得到后备存放区的维护。若窗口有一部分未指出内容时，就会传送一个事件，通知客户端重绘那部分内容。

**这也就是为什么之前在VM中跑的时候放视频会那么卡，因为VM本身调显卡就要跳一层虚拟化，然后container在编解码的时候只能使用CPU，CPU对解析图像是不太专业的，所以在高画质下，频繁的重绘就导致了效果很差**

